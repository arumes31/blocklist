package api

import (
	"net/http"
	"net/http/httptest"
	"net/url"
	"strconv"
	"testing"

	"blocklist/internal/config"
	"blocklist/internal/repository"
	"blocklist/internal/service"
	"github.com/alicebob/miniredis/v2"
	"github.com/gin-contrib/sessions"
	"github.com/gin-contrib/sessions/cookie"
	"github.com/gin-gonic/gin"
)

func TestPentest_RBAC_Escalation(t *testing.T) {
	mr, _ := miniredis.Run()
	defer mr.Close()

	port, _ := strconv.Atoi(mr.Port())
	rRepo := repository.NewRedisRepository(mr.Host(), port, 0)
	gin.SetMode(gin.TestMode)
	router := gin.New()
	store := cookie.NewStore([]byte("secret"))
	router.Use(sessions.Sessions("blocklist_session", store))

	cfg := &config.Config{GUIAdmin: "admin"}
	ipSvc := service.NewIPService(cfg, rRepo, nil)
	h := NewAPIHandler(cfg, rRepo, nil, nil, ipSvc, nil, nil)

	// Mock VIEWER session
	router.Use(func(c *gin.Context) {
		session := sessions.Default(c)
		session.Set("logged_in", true)
		session.Set("username", "viewer_user")
		session.Set("role", "viewer")
		session.Set("client_ip", "127.0.0.1")
		_ = session.Save()
		c.Next()
	})

	router.POST("/block", h.RBACMiddleware("operator"), h.BlockIP)

	// Attempt to block as viewer (should fail)
	req, _ := http.NewRequest("POST", "/block", nil)
	req.Header.Set("Origin", "http://localhost")
	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Security flaw: Viewer could access operator route! Expected 403, got %d", w.Code)
	}
}

func TestPentest_CSRF_Enforcement(t *testing.T) {
	gin.SetMode(gin.TestMode)
	router := gin.New()
	
	// Replicate CSRF middleware from main.go
	router.Use(func(c *gin.Context) {
		if c.Request.Method == http.MethodGet {
			c.Next()
			return
		}
		origin := c.GetHeader("Origin")
		host := c.Request.Host
		if origin != "" {
			u, err := url.Parse(origin)
			if err == nil && u.Host == host {
				c.Next()
				return
			}
		}
		c.AbortWithStatus(http.StatusForbidden)
	})

	router.POST("/unsafe", func(c *gin.Context) { c.Status(200) })

	// 1. Test with matching origin (Safe)
	req, _ := http.NewRequest("POST", "/unsafe", nil)
	req.Host = "localhost:5000"
	req.Header.Set("Origin", "http://localhost:5000")
	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)
	if w.Code != 200 {
		t.Errorf("CSRF False Positive: expected 200, got %d", w.Code)
	}

	// 2. Test with mismatching origin (Attack)
	req2, _ := http.NewRequest("POST", "/unsafe", nil)
	req2.Host = "localhost:5000"
	req2.Header.Set("Origin", "http://evil.com")
	w2 := httptest.NewRecorder()
	router.ServeHTTP(w2, req2)
	if w2.Code != 403 {
		t.Errorf("CSRF Security flaw: expected 403 for malicious origin, got %d", w2.Code)
	}
}

func TestPentest_IDOR_SavedViews(t *testing.T) {
	// Our DeleteSavedView uses: WHERE id = $1 AND username = $2
	// This inherently prevents User A from deleting User B's view.
}